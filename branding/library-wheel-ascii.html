<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Archivist's Wheel - ASCII</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0908;
      overflow: hidden;
      font-family: monospace;
    }

    #info {
      position: absolute;
      bottom: 30px;
      width: 100%;
      text-align: center;
      color: #4a3c28;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      z-index: 100;
    }

    #info span {
      color: #8b7355;
    }
  </style>
</head>
<body>
  <div id="info">
    <span>The Archivist's Wheel</span> · Keeper of Knowledge · <em>Click to turn</em>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';

    let camera, scene, renderer, effect;
    let mainWheel;
    let shelfAssemblies = [];

    // Animation state
    let currentRotation = 0;
    let targetRotation = 0;
    let isAnimating = false;
    let autoRotateTimer = null;
    const SHELF_COUNT = 8;
    const ROTATION_PER_SHELF = (Math.PI * 2) / SHELF_COUNT;

    init();
    animate();
    scheduleNextRotation();

    function createGearDisc(radius, holeSize, teeth, thickness) {
      // Create a gear shape with diamond-shaped center hole (like RIT recreation)
      const shape = new THREE.Shape();

      // Outer edge with teeth
      const anglePerTooth = (Math.PI * 2) / teeth;
      const toothDepth = radius * 0.1;
      const toothWidth = anglePerTooth * 0.5;

      for (let i = 0; i < teeth; i++) {
        const angle = i * anglePerTooth;
        const r = radius;

        if (i === 0) {
          shape.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }

        // Tooth
        shape.lineTo(
          Math.cos(angle + toothWidth * 0.3) * (r + toothDepth),
          Math.sin(angle + toothWidth * 0.3) * (r + toothDepth)
        );
        shape.lineTo(
          Math.cos(angle + toothWidth * 0.7) * (r + toothDepth),
          Math.sin(angle + toothWidth * 0.7) * (r + toothDepth)
        );
        shape.lineTo(
          Math.cos(angle + toothWidth) * r,
          Math.sin(angle + toothWidth) * r
        );

        // Valley
        const nextAngle = (i + 1) * anglePerTooth;
        shape.lineTo(Math.cos(nextAngle) * r, Math.sin(nextAngle) * r);
      }

      // Diamond-shaped center hole (rotated square)
      if (holeSize > 0) {
        const holePath = new THREE.Path();
        const d = holeSize;
        holePath.moveTo(0, d);      // Top
        holePath.lineTo(d, 0);      // Right
        holePath.lineTo(0, -d);     // Bottom
        holePath.lineTo(-d, 0);     // Left
        holePath.lineTo(0, d);      // Back to top
        shape.holes.push(holePath);
      }

      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: thickness,
        bevelEnabled: false
      });
      geometry.center();
      return geometry;
    }

    function createOpenBook(color) {
      // Simple chunky book - one solid block that reads clearly as "book" in ASCII
      const bookGroup = new THREE.Group();

      const coverMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.85 });
      const pageMat = new THREE.MeshStandardMaterial({ color: 0xf5f5e8, roughness: 0.9 });

      // Main page block - one solid cream rectangle
      const pageBlock = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 0.4, 2.5),
        pageMat
      );
      bookGroup.add(pageBlock);

      // Colored cover/border around edges
      const coverTop = new THREE.Mesh(
        new THREE.BoxGeometry(3.7, 0.12, 0.2),
        coverMat
      );
      coverTop.position.set(0, 0.15, -1.35);
      bookGroup.add(coverTop);

      const coverBottom = new THREE.Mesh(
        new THREE.BoxGeometry(3.7, 0.12, 0.2),
        coverMat
      );
      coverBottom.position.set(0, 0.15, 1.35);
      bookGroup.add(coverBottom);

      const coverLeft = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.12, 2.5),
        coverMat
      );
      coverLeft.position.set(-1.85, 0.15, 0);
      bookGroup.add(coverLeft);

      const coverRight = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.12, 2.5),
        coverMat
      );
      coverRight.position.set(1.85, 0.15, 0);
      bookGroup.add(coverRight);

      return bookGroup;
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function scheduleNextRotation() {
      // Random delay between 3-6 seconds
      const delay = 3000 + Math.random() * 3000;
      autoRotateTimer = setTimeout(() => {
        // Rotate to next shelf position
        targetRotation = currentRotation + ROTATION_PER_SHELF;
        isAnimating = true;
      }, delay);
    }

    function init() {
      // 3/4 VIEW - positioned to see INTO the wheel (between the side walls)
      camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(20, 5, 18);
      camera.lookAt(0, 0, 0);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0908);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xfff5e0, 1.3);
      keyLight.position.set(-4, 6, 10);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0xe0e8ff, 0.5);
      fillLight.position.set(6, 2, 6);
      scene.add(fillLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.25);
      backLight.position.set(0, 0, -8);
      scene.add(backLight);

      // Materials
      const brassMat = new THREE.MeshStandardMaterial({
        color: 0xd4a855,
        metalness: 0.75,
        roughness: 0.25
      });

      const copperMat = new THREE.MeshStandardMaterial({
        color: 0xcd7f32,
        metalness: 0.7,
        roughness: 0.3
      });

      const woodMat = new THREE.MeshStandardMaterial({
        color: 0x9b7653,
        metalness: 0.0,
        roughness: 0.8
      });

      const darkWoodMat = new THREE.MeshStandardMaterial({
        color: 0x5c4033,
        metalness: 0.0,
        roughness: 0.85
      });

      const ironMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        metalness: 0.8,
        roughness: 0.4
      });

      // === SUPPORT FRAME (perpendicular - posts on SIDES of wheel) ===
      // Like RIT recreation: vertical posts along Z-axis, supporting axle from sides

      const frameDepth = 8.0; // How far apart the side posts are

      // Front-left leg (angled outward)
      const legGeom = new THREE.BoxGeometry(0.6, 11, 0.6);
      const frontLeftLeg = new THREE.Mesh(legGeom, darkWoodMat);
      frontLeftLeg.position.set(-0.8, -0.5, frameDepth / 2 + 0.5);
      frontLeftLeg.rotation.x = -0.08; // Slight outward angle
      scene.add(frontLeftLeg);

      // Front-right leg
      const frontRightLeg = new THREE.Mesh(legGeom, darkWoodMat);
      frontRightLeg.position.set(0.8, -0.5, frameDepth / 2 + 0.5);
      frontRightLeg.rotation.x = -0.08;
      scene.add(frontRightLeg);

      // Back-left leg
      const backLeftLeg = new THREE.Mesh(legGeom, darkWoodMat);
      backLeftLeg.position.set(-0.8, -0.5, -frameDepth / 2 - 0.5);
      backLeftLeg.rotation.x = 0.08;
      scene.add(backLeftLeg);

      // Back-right leg
      const backRightLeg = new THREE.Mesh(legGeom, darkWoodMat);
      backRightLeg.position.set(0.8, -0.5, -frameDepth / 2 - 0.5);
      backRightLeg.rotation.x = 0.08;
      scene.add(backRightLeg);

      // Top beam (runs along Z-axis, above wheel)
      const topBeamGeom = new THREE.BoxGeometry(0.7, 0.7, frameDepth + 2);
      const topBeam = new THREE.Mesh(topBeamGeom, darkWoodMat);
      topBeam.position.set(0, 5.8, 0);
      scene.add(topBeam);

      // Cross braces at top (connecting front and back pairs)
      const topCrossGeom = new THREE.BoxGeometry(2.2, 0.5, 0.5);
      const frontCross = new THREE.Mesh(topCrossGeom, darkWoodMat);
      frontCross.position.set(0, 5.2, frameDepth / 2 + 0.3);
      scene.add(frontCross);

      const backCross = new THREE.Mesh(topCrossGeom, darkWoodMat);
      backCross.position.set(0, 5.2, -frameDepth / 2 - 0.3);
      scene.add(backCross);

      // Bottom cross beam (base)
      const bottomBeamGeom = new THREE.BoxGeometry(2.5, 0.4, frameDepth + 2.5);
      const bottomBeam = new THREE.Mesh(bottomBeamGeom, darkWoodMat);
      bottomBeam.position.set(0, -5.8, 0);
      scene.add(bottomBeam);

      // Axle bearing blocks (on the top beam, holding the axle)
      const bearingGeom = new THREE.BoxGeometry(1.2, 1.0, 0.8);
      const frontBearing = new THREE.Mesh(bearingGeom, woodMat);
      frontBearing.position.set(0, 5.2, frameDepth / 2 - 0.5);
      scene.add(frontBearing);

      const backBearing = new THREE.Mesh(bearingGeom, woodMat);
      backBearing.position.set(0, 5.2, -frameDepth / 2 + 0.5);
      scene.add(backBearing);

      // === MAIN BOOK WHEEL ===
      mainWheel = new THREE.Group();
      scene.add(mainWheel);

      const wheelRadius = 4.8;
      const wheelDepth = 6.5; // Distance between side walls - wide enough to see shelves clearly

      // === CIRCULAR SIDE WALLS (the key feature!) ===

      // Front side wall (large wooden disc)
      const sideWallGeom = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.25, 64);
      const frontWall = new THREE.Mesh(sideWallGeom, woodMat);
      frontWall.rotation.x = Math.PI / 2;
      frontWall.position.z = wheelDepth / 2;
      mainWheel.add(frontWall);

      // Back side wall
      const backWall = new THREE.Mesh(sideWallGeom, woodMat);
      backWall.rotation.x = Math.PI / 2;
      backWall.position.z = -wheelDepth / 2;
      mainWheel.add(backWall);

      // Outer rim connecting the walls
      const rimGeom = new THREE.TorusGeometry(wheelRadius, 0.2, 12, 64);
      const frontRim = new THREE.Mesh(rimGeom, darkWoodMat);
      frontRim.position.z = wheelDepth / 2;
      mainWheel.add(frontRim);

      const backRim = new THREE.Mesh(rimGeom, darkWoodMat);
      backRim.position.z = -wheelDepth / 2;
      mainWheel.add(backRim);

      // === DECORATIVE GEARS ON SIDE WALLS ===
      // 8 radial stacks: Central (small) → Middle ring (8 small) → Outer ring (8 large)

      // Central gear around the axle (small - 50% of before)
      const centralGearGeom = createGearDisc(0.8, 0.2, 16, 0.15);

      const centralGearFront = new THREE.Mesh(centralGearGeom, brassMat);
      centralGearFront.position.set(0, 0, wheelDepth / 2 + 0.15);
      mainWheel.add(centralGearFront);

      const centralGearBack = new THREE.Mesh(centralGearGeom, brassMat);
      centralGearBack.position.set(0, 0, -wheelDepth / 2 - 0.15);
      centralGearBack.rotation.y = Math.PI;
      mainWheel.add(centralGearBack);

      // Middle ring - 8 small gears encircling the central gear
      // (tiny gaps between them - not driving each other, but driving outer gears)
      const middleGearGeom = createGearDisc(0.65, 0.18, 12, 0.15);
      const middleRingRadius = 1.55; // Just outside central gear

      // Outer ring - 8 large gears at the edge
      const outerGearGeom = createGearDisc(1.3, 0.35, 20, 0.15);
      const outerRingRadius = 3.4; // Near the wheel rim

      // Front wall - 8 radial stacks
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 - Math.PI / 2; // Start at 12 o'clock

        // Middle gear
        const middleGear = new THREE.Mesh(middleGearGeom, copperMat);
        middleGear.position.set(
          Math.cos(angle) * middleRingRadius,
          Math.sin(angle) * middleRingRadius,
          wheelDepth / 2 + 0.15
        );
        mainWheel.add(middleGear);

        // Outer gear
        const outerGear = new THREE.Mesh(outerGearGeom, brassMat);
        outerGear.position.set(
          Math.cos(angle) * outerRingRadius,
          Math.sin(angle) * outerRingRadius,
          wheelDepth / 2 + 0.15
        );
        mainWheel.add(outerGear);
      }

      // Back wall - 8 radial stacks mirrored
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;

        // Middle gear
        const middleGear = new THREE.Mesh(middleGearGeom, copperMat);
        middleGear.position.set(
          Math.cos(angle) * middleRingRadius,
          Math.sin(angle) * middleRingRadius,
          -wheelDepth / 2 - 0.15
        );
        middleGear.rotation.y = Math.PI;
        mainWheel.add(middleGear);

        // Outer gear
        const outerGear = new THREE.Mesh(outerGearGeom, brassMat);
        outerGear.position.set(
          Math.cos(angle) * outerRingRadius,
          Math.sin(angle) * outerRingRadius,
          -wheelDepth / 2 - 0.15
        );
        outerGear.rotation.y = Math.PI;
        mainWheel.add(outerGear);
      }

      // Central axle hub
      const hubGeom = new THREE.CylinderGeometry(0.5, 0.5, wheelDepth + 1, 24);
      const hub = new THREE.Mesh(hubGeom, ironMat);
      hub.rotation.x = Math.PI / 2;
      mainWheel.add(hub);

      // Hub caps
      const hubCapGeom = new THREE.CylinderGeometry(0.7, 0.7, 0.2, 24);
      const hubCapFront = new THREE.Mesh(hubCapGeom, brassMat);
      hubCapFront.rotation.x = Math.PI / 2;
      hubCapFront.position.z = wheelDepth / 2 + 0.35;
      mainWheel.add(hubCapFront);

      const hubCapBack = new THREE.Mesh(hubCapGeom, brassMat);
      hubCapBack.rotation.x = Math.PI / 2;
      hubCapBack.position.z = -wheelDepth / 2 - 0.35;
      mainWheel.add(hubCapBack);

      // === READING SHELVES (8 tilted lecterns around the wheel) ===
      const bookColors = [0x8b0000, 0x1a1a4e, 0x2f4f2f, 0x4a3020, 0x3d0c02, 0x1a3a1a, 0x3d2b1f, 0x191940];

      for (let i = 0; i < SHELF_COUNT; i++) {
        const angle = (i / SHELF_COUNT) * Math.PI * 2;

        const shelfAssembly = new THREE.Group();

        // Position at radius
        const shelfRadius = wheelRadius - 1.2;
        shelfAssembly.position.set(
          Math.cos(angle) * shelfRadius,
          Math.sin(angle) * shelfRadius,
          0
        );

        // Create tilted reading desk (lectern style)
        const deskGroup = new THREE.Group();

        // Tilted reading surface - larger and more visible
        const surfaceGeom = new THREE.BoxGeometry(2.8, 0.12, wheelDepth - 0.4);
        const surface = new THREE.Mesh(surfaceGeom, woodMat);
        deskGroup.add(surface);

        // Lip at the bottom (to hold books from sliding) - more prominent
        const lipGeom = new THREE.BoxGeometry(2.8, 0.35, 0.15);
        const lip = new THREE.Mesh(lipGeom, darkWoodMat);
        lip.position.set(0, 0.18, -(wheelDepth - 0.4) / 2 - 0.06);
        deskGroup.add(lip);

        // Side rails - more visible
        const sideRailGeom = new THREE.BoxGeometry(2.9, 0.25, 0.12);
        const leftRail = new THREE.Mesh(sideRailGeom, darkWoodMat);
        leftRail.position.set(0, 0.12, -wheelDepth / 2 + 0.25);
        deskGroup.add(leftRail);

        const rightRail = new THREE.Mesh(sideRailGeom, darkWoodMat);
        rightRail.position.set(0, 0.12, wheelDepth / 2 - 0.25);
        deskGroup.add(rightRail);

        // Tilt the desk outward (like a lectern facing outward)
        deskGroup.rotation.z = -0.4; // Slightly more tilt for visibility
        deskGroup.position.set(0.8, 0, 0);
        shelfAssembly.add(deskGroup);

        // Open book sitting on the tilted desk
        const bookColor = bookColors[i % bookColors.length];
        const openBook = createOpenBook(bookColor);
        // No rotation - just position on the desk
        openBook.position.set(1.0, 0.5, 0);
        shelfAssembly.add(openBook);

        mainWheel.add(shelfAssembly);
        shelfAssemblies.push(shelfAssembly);
      }

      // Radial spokes (connecting center to shelves)
      for (let i = 0; i < SHELF_COUNT; i++) {
        const angle = (i / SHELF_COUNT) * Math.PI * 2 + ROTATION_PER_SHELF / 2;
        const spokeGeom = new THREE.BoxGeometry(0.15, wheelRadius - 1.2, 0.15);
        const spoke = new THREE.Mesh(spokeGeom, darkWoodMat);
        spoke.rotation.z = angle;
        spoke.position.set(
          Math.cos(angle) * (wheelRadius / 2 - 0.3),
          Math.sin(angle) * (wheelRadius / 2 - 0.3),
          0
        );
        mainWheel.add(spoke);
      }

      // === READING DESK ===
      const deskGeom = new THREE.BoxGeometry(2.5, 0.12, 1.8);
      const desk = new THREE.Mesh(deskGeom, woodMat);
      desk.position.set(0, -3, 5.5);
      scene.add(desk);

      // Desk legs
      const deskLegGeom = new THREE.BoxGeometry(0.15, 2.2, 0.15);
      [[-1, -4.1, 4.8], [1, -4.1, 4.8], [-1, -4.1, 6.2], [1, -4.1, 6.2]].forEach(pos => {
        const leg = new THREE.Mesh(deskLegGeom, darkWoodMat);
        leg.position.set(...pos);
        scene.add(leg);
      });

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // ASCII Effect
      effect = new AsciiEffect(renderer, ' .:-=+*#%@', {
        invert: true,
        resolution: 0.15
      });
      effect.setSize(window.innerWidth, window.innerHeight);
      effect.domElement.style.color = '#d4a855';
      effect.domElement.style.backgroundColor = '#0a0908';
      effect.domElement.style.fontFamily = '"Courier New", monospace';
      effect.domElement.style.fontSize = '10px';
      effect.domElement.style.lineHeight = '8px';

      document.body.appendChild(effect.domElement);

      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousemove', onMouseMove);

      // Click to manually rotate to next book
      document.addEventListener('click', () => {
        if (!isAnimating) {
          clearTimeout(autoRotateTimer);
          targetRotation = currentRotation + ROTATION_PER_SHELF;
          isAnimating = true;
        }
      });
    }

    function onMouseMove(event) {
      const x = (event.clientX / window.innerWidth) * 2 - 1;
      const y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Subtle camera movement based on mouse position
      camera.position.x = 20 + x * 3;
      camera.position.y = 5 + y * 2;
      camera.lookAt(0, 0, 0);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      effect.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Smooth easing animation
      if (isAnimating) {
        const diff = targetRotation - currentRotation;

        if (Math.abs(diff) < 0.001) {
          // Snap to target and stop
          currentRotation = targetRotation;
          isAnimating = false;
          scheduleNextRotation();
        } else {
          // Ease toward target (cubic ease-out feel)
          currentRotation += diff * 0.03;
        }
      }

      mainWheel.rotation.z = currentRotation;

      // Counter-rotate shelves to keep books upright
      shelfAssemblies.forEach(shelf => {
        shelf.rotation.z = -currentRotation;
      });

      effect.render(scene, camera);
    }
  </script>
</body>
</html>
